CREATE CONSTRAINT ON (c:Class) ASSERT c.uuid IS UNIQUE;
CREATE CONSTRAINT ON (m:Method) ASSERT m.uuid IS UNIQUE;

:auto USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM 'file:///classes.csv' AS row
WITH row, SPLIT(row.interfaces, '>|<') AS infaces, SPLIT(row.fields, '>|<') AS fields

CREATE (c:Class {uuid:row.uuid, name:row.name, superClass:row.superClass, interfaces:infaces, fields:fields})
SET c.isInterface = CASE row.isInterface WHEN 'TRUE' THEN true ELSE false END,
  c.hasSuperClass = CASE row.hasSuperClass WHEN 'TRUE' THEN true ELSE false END,
  c.hasInterfaces = CASE row.hasInterfaces WHEN 'TRUE' THEN true ELSE false END;


LOAD CSV WITH HEADERS FROM 'file:///classes.csv' AS row
WITH row, SPLIT(row.interfaces, '>|<') AS infaces, SPLIT(row.fields, '>|<') AS fields
CREATE (c:Class)
SET c = row, c.isInterface = CASE row.isInterface WHEN 'TRUE' THEN true ELSE false END,
  c.hasSuperClass = CASE row.hasSuperClass WHEN 'TRUE' THEN true ELSE false END,
  c.hasInterfaces = CASE row.hasInterfaces WHEN 'TRUE' THEN true ELSE false END,
  c.interfaces = infaces, c.fields = fields;

CALL apoc.load.csv($path, {skip:1, limit:1, header:true,
mapping:{
  hasSuperClass: {type:'boolean'},
  hasInterfaces: {type:'boolean'},
  isInterface: {type:'boolean'},
}})
YIELD map
RETURN *;

WITH  AS path
CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true, mapping:{ hasSuperClass: {type:\'boolean\'}, hasInterfaces: {type:\'boolean\'}, isInterface: {type:\'boolean\'}, interfaces: {array:true, arraySep:\'|\'}, fields: {array:true, arraySep:\'|\'}}}) YIELD map AS row RETURN row','MERGE (c:Class {uuid:row.uuid}) ON CREATE SET c = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true, mapping:{ isStatic: {type:\'boolean\'}}}) YIELD map AS row RETURN row','MERGE (m:Method {uuid:row.uuid}) ON CREATE SET m = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true}) YIELD map AS row RETURN row','MATCH (source:Class) MERGE (m:Method {uuid:row.uuid}) ON CREATE SET m = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true}) YIELD map AS row RETURN row','MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2)', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/extends.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2)", {batchSize:1000, iterateList:true, parallel:true})
CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/interfaces.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:INTERFACE {uuid: row.uuid}]->(c2)", {batchSize:1000, iterateList:true, parallel:true})
CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/has.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c:Class {uuid: row.classRef}) MATCH (m:Method {uuid: row.MethodRef}) MERGE (c)-[e:HAS {uuid: row.uuid}]->(m)", {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/calls.csv', {header:true}) YIELD map AS row RETURN row","MATCH (m1:Method {uuid: row.source}) MATCH (m2:Method {uuid: row.target}) MERGE (m1)-[e:CALL {uuid: row.uuid, lineNum: row.lineNum, realCallType: row.realCallType}]->(m2)", {batchSize:1000, iterateList:true, parallel:true})
MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2) RETURN *

向上查找

查找当前类的所有父类和接口
match (c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class) return *

查找当前类的所有父类和接口，返回除了当前对象外的，所有对象名
match p=(c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class)  return distinct c2.name

查找父类或接口中存在某函数的对象名
match p=(c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class) match (c2)-[:HAS]->(m:Method {subSignature:"xxx cancelRowUpdates"}) return c2.name

向下查找

查找当前对象的子类，实现了某函数的 对象名


在获得当前函数调用后，需要向上向下都进行查找，然后在进一步发散查找下一个节点

建立其同一棵树上的相同函数的依赖边，然后由neo4j进行source-》sink的查找

relationships(p) 返回所有的关系边

match p=(m2:Method {name:"hashCode"}) -[:CALL|ALIAS*]-> (m1:Method {isSink:true, name:"invoke"}) return m1,m2 limit 1
match (source:Method {name:"readObject"}) match (sink:Method {name:"invoke",isSink:true}) call apoc.path.spanningTree(source, {relationshipFilter:"CALL|ALIAS", minLevel:1,endNodes:[sink],bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops

match (source:Method {name:"readObject"}) call apoc.path.spanningTree(source, {relationshipFilter:"CALL|ALIAS", minLevel:1, maxLevel:5, bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops

match (source:Method {name:"readObject"}) call apoc.path.subgraphAll(source, {relationshipFilter:"CALL|ALIAS", bfs:true,limit:1}) YIELD nodes, relationships
RETURN nodes, relationships

match p=(c1:Class)-[:EXTENDS|INTERFACE*]->(c2:Class {name:"java.io.Serializable"})
match (source:Method {name:"hashCode"})
match (sink:Method {name:"invoke",isSink:true})
call apoc.path.spanningTree(source, {relationshipFilter:"CALL>|ALIAS",endNodes:[sink],bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops limit 1


match (m1:Method {signature:"<javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>"})-[:CALL]->(m2:Method {name:"toString"})-[:ALIAS*]-(m3:Method {signature:"<org.apache.commons.collections.keyvalue.TiedMapEntry: java.lang.String toString()>"})-[:CALL]->(m4:Method {name:"getValue"})-[:CALL]->(m5:Method {name:"get"})-[:ALIAS*1..2]-(m6:Method {name:"get"})-[:CALL]->(m7:Method {name:"transform"})-[:ALIAS*]-(m8:Method)-[:CALL]->(m9:Method {isSink:true}) return *




// class
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"classReference\",null) yield value","MERGE (c:Class {name:value.name}) ON CREATE SET c = value",{batchSize:5000, iterateList:true, parallel:true})
// method
CALL apoc.periodic.iterate("call apoc.mongodb.find(\"mongodb://root:password@localhost:27017\",\"graph\",\"methodReference\",null,{`_class`:0,`body`:0}, null) yield value","MERGE(m:Method {_id:value._id} ) ON CREATE SET m = value",{batchSize:5000, iterateList:true, parallel:true})
// extend
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"Extend\",null) yield value","MATCH( c1:Class {_id:value.source} ) MATCH ( c2:Class { _id:value.target } ) MERGE (c1) -[e:EXTENDS { _id:value._id }] -> (c2)",{batchSize:1000, iterateList:true, parallel:false})
// has
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"Has\",null) yield value","MATCH(c:Class{_id:value.classNode}) MATCH(m:Method { _id:value.MethodNode }) MERGE (c) -[e:HAS { _id:value._id }]-> (m)",{batchSize:1000, iterateList:true, parallel:false})
// interface
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"Interfaces\",null) yield value","MATCH( c1:Class {_id:value.source} ) MATCH ( c2:Class { _id:value.target } ) MERGE (c1) -[e:INTERFACE { _id:value._id }] -> (c2)",{batchSize:1000, iterateList:true, parallel:false})
// alias
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"Alias\",null) yield value","MATCH ( m1:Method {_id:value.source} ) MATCH ( m2:Method {_id:value.target }) MERGE (m1)-[e:ALIAS {_id:value._id}]-(m2)",{batchSize:1000, iterateList:true, parallel:false})
// call
CALL apoc.periodic.iterate("call apoc.mongodb.get(\"mongodb://root:password@localhost:27017\",\"graph\",\"Call\",null) yield value","MATCH ( m1:Method {_id:value.source} ) MATCH ( m2:Method {_id:value.target }) MERGE (m1)-[e:CALL {_id:value._id, lineNum:value.lineNum, isPolluted:value.isPolluted, pollutedPosition:value.pollutedPosition, realCallType:value.realCallType, invokerType: value.invokerType }]->(m2)",{batchSize:5000, iterateList:true, parallel:false})

call apoc.load.json("file:///Users/wh1t3P1g/Downloads/classReference") yield value
MERGE (c:Class {name:value.name}) ON CREATE SET c = value
call apoc.load.json("file:///Users/wh1t3P1g/Downloads/methodReference") yield value 
MERGE(m:Method {_id:value._id} ) ON CREATE SET m = value


//cc10
match (m1:Method {SIGNATURE:"<java.tabby.util.HashSet: void readObject(java.io.ObjectInputStream)>"})-[:CALL]->(m2:Method {NAME:"put"})-[:CALL]->(m3:Method {NAME:"hash"})-[:CALL]->(m4:Method {NAME:"hashCode"})-[:ALIAS*]-(m5:Method {SIGNATURE:"<org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()>"})-[:CALL]->(m6:Method {NAME:"getValue"})-[:CALL]->(m7:Method {NAME:"get"})-[:ALIAS*1..2]-(m8:Method {NAME:"get"})-[:CALL]->(m9:Method {NAME:"transform"})-[:ALIAS*]-(m10:Method)-[:CALL]->(m11:Method {IS_SINK:true}) return *


match (source:Method {SIGNATURE:"<java.tabby.util.HashSet: void readObject(java.io.ObjectInputStream)>"})
match (sink:Method {IS_SINK:true, NAME:"invoke"})
call apoc.algo.allSimplePaths(source, sink, "CALL>|ALIAS", 12) yield path
return * limit 20

//cc2
match (m1:Method {SIGNATURE:"<java.tabby.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>"})-[:CALL ]->(m2:Method {NAME:"heapify"})-[:CALL ]->(m3)-[:CALL ]->(m4:Method {NAME:"siftDownUsingComparator"})-[:CALL ]->(m5)-[:ALIAS*]-(m6 {SIGNATURE:"<org.apache.commons.collections.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)>"})-[:CALL ]->(m7)-[:ALIAS*]-(m8:Method)-[:CALL]->(m9:Method {IS_SINK:true}) return *

match (source:Method {SIGNATURE:"<org.apache.commons.collections.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)>"})
match (sink:Method {IS_SINK:true, NAME:"invoke"})
call apoc.algo.allSimplePaths(sink, source, "<CALL|ALIAS", 12) yield path
return * limit 20

match (source:Method {NAME:"transform"})
match (sink:Method {IS_SINK:true, NAME:"invoke"})
call apoc.algo.allSimplePaths(sink, source, "<CALL|ALIAS", 3) yield path
return * limit 20

match (source:Method {SIGNATURE:"<java.tabby.util.HashSet: void readObject(java.io.ObjectInputStream)>"})
match (sink:Method {IS_SINK:true, NAME:"invoke"})
call apoc.algo.allSimplePaths(sink, source, "<CALL|ALIAS", 3) yield path
return * limit 20

match (sink:Method {IS_SINK:true,NAME:"lookup"})<-[:CALL]-(m1:Method) where m1.IS_STATIC=true or m1.IS_SERIALIZABLE=true
match (source:Method {IS_SERIALIZABLE:true, HAS_PARAMETERS:false}) where source.NAME =~ "get.*"
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 12) yield path
return * limit 20

//cc10
match (m1:Method {SIGNATURE:"<java.tabby.util.HashSet: void readObject(java.io.ObjectInputStream)>"})-[:CALL ]->(m2:Method {NAME:"put"})-[:CALL ]->(m3:Method {NAME:"hash"})-[:CALL ]->(m4:Method {NAME:"hashCode"})-[:ALIAS*]-(m5:Method {SIGNATURE:"<org.apache.commons.collections.keyvalue.TiedMapEntry: int hashCode()>"})-[:CALL ]->(m6:Method {NAME:"getValue"})-[:CALL]->(m7:Method {NAME:"get"})-[:ALIAS*1..2]-(m8:Method {NAME:"get"})-[:CALL]->(m9:Method {NAME:"transform"})-[:ALIAS*]-(m10:Method)-[:CALL]->(m11:Method {IS_SINK:true}) return *

((HashMap) out).values().toArray()[1].equals(((HashMap) d.outFlow).values().toArray()[1])

match (source:Method {SIGNATURE:"<java.tabby.util.HashSet: void readObject(java.io.ObjectInputStream)>"})
match (sink:Method {IS_SINK:true})
call apoc.algo.allSimplePaths(sink, source, "<CALL|ALIAS", 12) yield path
return * limit 20

match (source:Method {SIGNATURE:"<java.tabby.util.Hashtable: void readObject(java.io.ObjectInputStream)>"})
match (sink:Method {IS_SINK:true})<-[:CALL]-(m1:Method {NAME:"transform"})
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 12) yield path
return * limit 20


match (m1:Method {SIGNATURE:"<java.tabby.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>"})-[:CALL ]->(m2:Method {NAME:"heapify"})-[:CALL ]->(m3)-[:CALL ]->(m4:Method {NAME:"siftDownUsingComparator"})-[:CALL ]->(m5)-[:ALIAS*]-(m6 {SIGNATURE:"<org.apache.commons.collections.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)>"})-[:CALL ]->(m7)-[:ALIAS*]-(m8:Method)-[:CALL]->(m9:Method {IS_SINK:true}) return *

//cc2
match (m1:Method {SIGNATURE:"<java.tabby.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>"})-[:CALL ]->(m2:Method {NAME:"heapify"})-[:CALL ]->(m3)-[:CALL ]->(m4:Method {NAME:"siftDownUsingComparator"})-[:CALL ]->(m5)-[:ALIAS*]-(m6 {SIGNATURE:"<org.apache.commons.collections.comparators.TransformingComparator: int compare(java.lang.Object,java.lang.Object)>"})-[:CALL ]->(m7)-[:ALIAS*]-(m8:Method)-[:CALL]->(m9:Method {isSink:true}) return *



match path=(c:Class)-[:INTERFACE|EXTENDS*]->(c1:Class {NAME:"java.lang.reflect.InvocationHandler"}) 
where exists{ 
  match (c)-[:INTERFACE|EXTENDS*]->(c2:Class {NAME:"java.io.Serializable"})
} 
return path


match (source:Method {NAME:"readObject"})
match (sink:Method {IS_SINK:true,NAME:"lookup"})<-[:CALL]-(m1:Method)
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 12) yield path
return * limit 20